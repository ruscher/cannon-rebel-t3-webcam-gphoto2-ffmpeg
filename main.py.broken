#!/usr/bin/env python3
import sys
import subprocess
import os
import signal
import gi
import re
import glob
import time

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
gi.require_version('Gst', '1.0')
gi.require_version('GstVideo', '1.0')
from gi.repository import Gtk, Adw, Gio, GLib, Gdk, GdkPixbuf, Gst, GstVideo
from utils.i18n import _

# Initialize GStreamer
Gst.init(None)

class WebcamApp(Adw.Application):
    def __init__(self):
        # Unique application_id per instance so multiple windows are truly independent
        instance_id = os.getpid()
        super().__init__(application_id=f'com.biglinux.BigDigiCam.pid{instance_id}',
                         flags=Gio.ApplicationFlags.NON_UNIQUE)
        self.process = None
        self.log_process = None
        self.camera_name = _("Nenhuma câmera detectada")
        self.camera_detected = False
        self.camera_list = []
        self.udp_port = 5000 + (instance_id % 1000)
        self.current_mode = "photo"  # "photo" or "video"
        self.last_photo = None
        self.my_video_device = None  # The /dev/videoX assigned to THIS instance
        self._hotplug_timer = None
        self.is_capturing = False # True if photo or webcam is starting/running
        self._detecting = False # Lock for detect_camera
        self._webcam_retry_count = 0 
        
        # Setup Dark Mode
        manager = Adw.StyleManager.get_default()
        manager.set_color_scheme(Adw.ColorScheme.PREFER_DARK)

    def do_activate(self):
        self.win = Adw.ApplicationWindow(application=self)
        self.win.set_default_size(702, 525)
        
        # Detect camera first (will update UI on finish)
        self.detect_camera(callback=self._update_camera_dropdown)
        self.win.set_title(_("Big DigiCam"))
        
        # Main box
        # Main box with ToastOverlay
        # Main root overlay to allow top-aligned toasts over everything
        self.root_overlay = Gtk.Overlay()
        self.win.set_content(self.root_overlay)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.root_overlay.set_child(main_box)
        
        # No Top Toast in Root Overlay


        
        # Apply CSS
        self.apply_css()
        
        # ===== HEADER BAR =====
        header = Adw.HeaderBar()
        header.set_centering_policy(Adw.CenteringPolicy.STRICT)
        main_box.append(header)
        
        # InlineViewSwitcher with round style as title widget
        self.view_switcher = Adw.InlineViewSwitcher()
        self.view_switcher.set_display_mode(Adw.InlineViewSwitcherDisplayMode.ICONS)
        self.view_switcher.add_css_class("round")
        header.set_title_widget(self.view_switcher)
        
        # Right side - Menu button with hamburger menu
        menu_btn = self._create_menu_button()
        header.pack_end(menu_btn)
        
        # Left side - Camera Status
        self.camera_status_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        
        is_error = not self.camera_detected
        icon_name = "dialog-error-symbolic" if is_error else "emblem-ok-symbolic"
        style_class = "error" if is_error else "success"
        
        self.status_icon = Gtk.Image.new_from_icon_name(icon_name)
        self.status_icon.add_css_class(style_class)
        self.camera_status_box.append(self.status_icon)
        
        self.camera_model = Gtk.StringList()
        if self.camera_detected:
            for cam in self.camera_list:
                self.camera_model.append(cam['name'])
        else:
            self.camera_model.append(self.camera_name)
            
        self.camera_dropdown = Gtk.DropDown(model=self.camera_model)
        self.camera_dropdown.add_css_class(style_class)
        self.camera_dropdown.set_valign(Gtk.Align.CENTER)
        self.camera_status_box.append(self.camera_dropdown)
        self._last_camera_list = list(self.camera_list)
        
        header.pack_start(self.camera_status_box)
        
        # Progress Bar
        self.loading_bar = Gtk.ProgressBar()
        self.loading_bar.add_css_class("thin-progress")
        self.loading_bar.set_visible(False)
        main_box.append(self.loading_bar)
        
        # Toast code moved to overlay

        
        # ===== PREVIEW AREA WITH OVERLAY =====
        overlay = Gtk.Overlay()
        overlay.set_vexpand(True)
        main_box.append(overlay)
        
        # Preview frame (base layer)
        preview_frame = Gtk.Frame()
        preview_frame.set_css_classes(["preview-frame"])
        preview_frame.set_margin_start(12)
        preview_frame.set_margin_end(12)
        preview_frame.set_margin_bottom(12)
        preview_frame.set_margin_top(12)
        overlay.set_child(preview_frame)
        
        # Floating FPS OSD (top-right corner)
        self.fps_label = Gtk.Label(label="")
        self.fps_label.set_css_classes(["osd", "fps-osd"])
        self.fps_label.set_halign(Gtk.Align.END)
        self.fps_label.set_valign(Gtk.Align.START)
        self.fps_label.set_margin_top(20)
        self.fps_label.set_margin_end(20)
        self.fps_label.set_visible(False)
        overlay.add_overlay(self.fps_label)

        # ===== TOP TOAST (OVERLAY) =====
        self.top_toast_revealer = Gtk.Revealer()
        self.top_toast_revealer.set_transition_type(Gtk.RevealerTransitionType.SLIDE_DOWN)
        self.top_toast_revealer.set_halign(Gtk.Align.CENTER)
        self.top_toast_revealer.set_valign(Gtk.Align.START)
        
        self.top_toast_box = Gtk.Box()
        self.top_toast_box.set_halign(Gtk.Align.CENTER)
        self.top_toast_box.set_margin_top(24) # Margin from top of overlay
        self.top_toast_revealer.set_child(self.top_toast_box)
        
        self.top_toast_label = Gtk.Label()
        self.top_toast_label.set_css_classes(["top-toast"])
        self.top_toast_box.append(self.top_toast_label)
        
        overlay.add_overlay(self.top_toast_revealer)
        
        # Floating toolbar (overlay layer)
        floating_toolbar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=16)
        floating_toolbar.set_css_classes(["floating-toolbar", "osd"])
        floating_toolbar.set_halign(Gtk.Align.CENTER)
        floating_toolbar.set_valign(Gtk.Align.END)
        floating_toolbar.set_margin_bottom(24)
        overlay.add_overlay(floating_toolbar)
        
        # Last photo thumbnail (circular)
        self.photo_thumbnail = Gtk.Button()
        self.photo_thumbnail.set_css_classes(["circular", "thumbnail-button"])
        self.photo_thumbnail.set_size_request(48, 48)
        self.photo_thumbnail.set_tooltip_text(_("Última foto"))
        self.photo_thumbnail.connect("clicked", self.on_thumbnail_clicked)
        
        # Use Adw.Avatar for better circular image handling
        self.thumbnail_avatar = Adw.Avatar(size=48, text="", show_initials=False)
        
        # Force 1:1 aspect ratio to ensure perfect circle
        aspect_frame = Gtk.AspectFrame(xalign=0.5, yalign=0.5, ratio=1.0, obey_child=False)
        aspect_frame.set_child(self.thumbnail_avatar)
        
        self.photo_thumbnail.set_child(aspect_frame)
        
        floating_toolbar.append(self.photo_thumbnail)
        
        # Main action button (Shutter)
        self.btn_action = Gtk.Button()
        self.btn_action.set_css_classes(["circular", "action-button"])
        self.btn_action.set_size_request(48, 48)
        self.btn_action.connect("clicked", self.on_action_clicked)
        floating_toolbar.append(self.btn_action)
        
        # Stop button (only visible during video)
        self.btn_stop = Gtk.Button()
        self.btn_stop.set_icon_name("media-playback-stop-symbolic")
        self.btn_stop.set_css_classes(["circular", "destructive-action"])
        self.btn_stop.set_size_request(52, 48)
        self.btn_stop.set_tooltip_text(_("Parar Webcam"))
        self.btn_stop.set_visible(False)
        self.btn_stop.connect("clicked", self.on_stop_clicked)
        floating_toolbar.append(self.btn_stop)
        
        # Stack for switching between photo preview and video status
        self.preview_stack = Adw.ViewStack()
        preview_frame.set_child(self.preview_stack)
        
        # Photo preview page
        photo_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        photo_box.set_valign(Gtk.Align.CENTER)
        photo_box.set_halign(Gtk.Align.CENTER)
        
        self.photo_preview = Gtk.Picture()
        self.photo_preview.set_size_request(400, 300)
        self.photo_preview.set_content_fit(Gtk.ContentFit.CONTAIN)
        photo_box.append(self.photo_preview)
        

        
        # Use ViewStack for proper ViewSwitcher integration
        photo_page = self.preview_stack.add_titled(photo_box, "photo", _("Foto"))
        photo_page.set_icon_name("camera-photo-symbolic")
        
        # Video preview page with GStreamer
        video_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        video_box.set_vexpand(True)
        video_box.set_hexpand(True)
        
        # GStreamer video widget
        self.video_picture = Gtk.Picture()
        self.video_picture.set_vexpand(True)
        self.video_picture.set_hexpand(True)
        self.video_picture.set_content_fit(Gtk.ContentFit.CONTAIN)
        video_box.append(self.video_picture)
        
        video_page = self.preview_stack.add_titled(video_box, "video", _("Webcam"))
        video_page.set_icon_name("camera-video-symbolic")
        
        # Connect ViewSwitcher to Stack
        self.view_switcher.set_stack(self.preview_stack)
        self.preview_stack.connect("notify::visible-child-name", self.on_mode_changed)
        
        # GStreamer pipeline (initialized as None)
        self.gst_pipeline = None
        
        # Initialize UI state
        self.update_mode_ui()
        self.load_last_photo()
        
        self.win.present()
        
        # Check for background session
        self.check_existing_session()
        
        # Setup actions for menu
        self._setup_actions()
        
        # Start hot-plug detection (poll every 5 seconds, and it's async)
        self._hotplug_timer = GLib.timeout_add(5000, self._poll_cameras)
        
        # Immediate detection on hardware events (USB plug/unplug or power on/off)
        self.volume_monitor = Gio.VolumeMonitor.get()
        self._mon_ids = [
            self.volume_monitor.connect("volume-added", lambda m, v: GLib.idle_add(self._on_hotplug_event)),
            self.volume_monitor.connect("volume-removed", lambda m, v: GLib.idle_add(self._on_hotplug_event)),
            self.volume_monitor.connect("mount-added", lambda m, mt: GLib.idle_add(self._on_hotplug_event)),
            self.volume_monitor.connect("mount-removed", lambda m, mt: GLib.idle_add(self._on_hotplug_event)),
        ]

    def _create_menu_button(self):
        menu = Gio.Menu.new()
        section = Gio.Menu.new()
        section.append(_("Atualizar Câmeras"), "app.refresh")
        section.append(_("Abrir outra câmera (Nova Janela)"), "app.new_window")
        section.append(_("Sobre"), "app.about")
        section.append(_("Sair"), "app.quit")
        menu.append_section(None, section)
        menu_button = Gtk.MenuButton()
        menu_button.set_icon_name("open-menu-symbolic")
        menu_button.set_menu_model(menu)
        menu_button.set_tooltip_text(_("Menu principal"))
        menu_button.set_css_classes(["flat"])
        return menu_button

    def _setup_actions(self):
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self._on_about)
        self.add_action(about_action)
        new_window_action = Gio.SimpleAction.new("new_window", None)
        new_window_action.connect("activate", self._on_new_window)
        self.add_action(new_window_action)
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self._on_quit)
        self.add_action(quit_action)
        
        refresh_action = Gio.SimpleAction.new("refresh", None)
        refresh_action.connect("activate", self._on_refresh)
        self.add_action(refresh_action)

    def _on_about(self, action=None, param=None):
        about = Adw.AboutDialog(
            application_name="Big DigiCam",
            application_icon="camera-photo-symbolic",
            developer_name="BigLinux",
            version="1.0",
            comments=_("Controlador de câmera digital usando gPhoto2 e FFmpeg"),
            website="https://github.com/biglinux",
            license_type=Gtk.License.GPL_3_0,
            developers=["BigLinux Team"],
        )
        about.present(self.win)

    def _on_refresh(self, action=None, param=None):
        self.show_toast(_("Buscando câmeras..."), "accent")
        self._manual_refresh = True
        self.detect_camera(callback=self._update_camera_dropdown)

    def _on_new_window(self, action=None, param=None):
        import sys
        subprocess.Popen([sys.executable, sys.argv[0]])

    def get_selected_camera_port(self):
        if not hasattr(self, 'camera_list') or not self.camera_list:
            return None
        selected_idx = self.camera_dropdown.get_selected()
        if selected_idx != Gtk.INVALID_LIST_POSITION and selected_idx < len(self.camera_list):
            return self.camera_list[selected_idx]['port']
        return None

    def _kill_my_processes(self):
        port = self.get_selected_camera_port()
        if port:
            subprocess.run(["pkill", "-9", "-f", f"gphoto2.*{port}"], check=False)
        else:
            subprocess.run(["pkill", "-9", "-f", "gphoto2"], check=False)
        subprocess.run(["pkill", "-9", "-f", f"ffmpeg.*udp://127.0.0.1:{self.udp_port}"], check=False)
        subprocess.run(["pkill", "-9", "-f", "gphoto2.*capture-movie"], check=False)

    def _on_quit(self, action=None, param=None):
        # Stop hot-plug polling
        if self._hotplug_timer:
            GLib.source_remove(self._hotplug_timer)
            self._hotplug_timer = None
        
        # Disconnect volume monitor signals
        if hasattr(self, 'volume_monitor') and hasattr(self, '_mon_ids'):
            for mon_id in self._mon_ids:
                self.volume_monitor.disconnect(mon_id)
            self._mon_ids = []
        
        self.stop_video_preview()
        if self.process:
            try:
                os.killpg(os.getpgid(self.process.pid), signal.SIGTERM)
            except:
                pass
        
        self._kill_my_processes()
        
        # Quit application
        self.quit()

    def apply_css(self):
        css = b"""
        .toolbar {
            background: alpha(@window_fg_color, 0.05);
            border-radius: 8px;
            padding: 6px;
        }
        
        .mode-button {
            min-width: 40px;
            min-height: 40px;
        }
        
        .mode-active {
            background: @accent_bg_color;
            color: @accent_fg_color;
        }
        
        .action-button {
            background: white;
            color: #333;
            border: 3px solid #666;
        }
        
        .action-button:hover {
            background: #eee;
        }
        
        .circular {
            border-radius: 999px;
            padding: 0;
            min-width: 48px;
            min-height: 48px;
        }

        .thumbnail-button {
            padding: 0;
            margin: 0;
            border: 2px solid white;
            min-width: 48px;
            min-height: 48px;
            border-radius: 999px;
            background: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .preview-frame {
            background: #1a1a1a;
            border-radius: 12px;
            border: 1px solid alpha(@window_fg_color, 0.1);
        }
        
        .status-bar {
            padding: 8px;
            background: alpha(@window_fg_color, 0.03);
            border-radius: 6px;
        }
        
        .recording {
            background: #e01b24;
            animation: pulse 1s infinite;
        }
        
        .floating-toolbar {
            padding: 12px 20px;
            border-radius: 32px;
            background: alpha(@window_bg_color, 0.85);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .fps-osd {
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            background: alpha(black, 0.7);
            color: #00ff00;
        }
        
        .top-toast {
            padding: 8px 18px;
            border-radius: 20px;
            background: #303030;
            color: white;
            font-weight: bold;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        .top-toast.accent { background: @accent_bg_color; color: @accent_fg_color; }
        .top-toast.success { background: #26a269; color: white; }
        .top-toast.warning { background: #cd9309; color: white; }
        .top-toast.error { background: #e01b24; color: white; }
        
        .app-notification {
            padding: 8px 16px;
            font-weight: 500;
        }
        
        .app-notification.accent {
            background: @accent_bg_color;
            color: @accent_fg_color;
        }
        
        .app-notification.success {
            background: #26a269;
            color: white;
        }
        
        .app-notification.warning {
            background: #e5a50a;
            color: black;
        }
        
        .app-notification.error {
            background: #e01b24;
            color: white;
        }
        
        .accent { color: @accent_bg_color; font-weight: bold; }
        .error { color: #e01b24; font-weight: bold; }
        .thin-progress > trough {
            min-height: 2px;
            background-color: transparent;
            box-shadow: none;
            border: none;
        }
        
        .thin-progress > trough > progress {
            min-height: 2px;
            border-radius: 999px;
            background-color: @accent_bg_color;
        }
        """
        
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

    def update_mode_ui(self):
        # Disable important controls during active operation
        is_busy = self.is_capturing
        self.btn_action.set_sensitive(not is_busy)
        if hasattr(self, 'camera_dropdown'):
            self.camera_dropdown.set_sensitive(not is_busy)

        if self.current_mode == "photo":
            self.btn_action.set_icon_name("camera-photo-symbolic")
            self.preview_stack.set_visible_child_name("photo")
        else:
            self.btn_action.set_icon_name("media-record-symbolic")
            self.preview_stack.set_visible_child_name("video")

    def on_mode_changed(self, stack, param):
        page_name = stack.get_visible_child_name()
        if page_name == "photo":
            self.current_mode = "photo"
            self.btn_action.set_icon_name("camera-photo-symbolic")
            if not self.is_capturing:
                self.btn_action.set_sensitive(True)
            self.fps_label.set_visible(False)
        else:
            self.current_mode = "video"
            self.btn_action.set_icon_name("media-record-symbolic")
            if not self.is_capturing:
                self.btn_action.set_sensitive(True)

    def on_action_clicked(self, btn):
        if self.is_capturing:
            return
        if self.current_mode == "photo":
            self.take_photo()
        else:
            self.start_webcam()

    def on_thumbnail_clicked(self, btn):
        if self.last_photo and os.path.exists(self.last_photo):
            subprocess.run(["xdg-open", self.last_photo])

    def load_last_photo(self):
        try:
            files = glob.glob("capt*.jpg")
            if files:
                self.last_photo = max(files, key=os.path.getctime)
                self.photo_preview.set_filename(self.last_photo)
                try:
                    texture = Gdk.Texture.new_from_filename(self.last_photo)
                    self.thumbnail_avatar.set_custom_image(texture)
                except:
                    pass
        except Exception as e:
            pass

    def detect_camera(self, callback=None):
        """Asynchronous camera detection."""
        if self._detecting:
            return
        
        self._detecting = True
        
        def run_detection():
            local_list = []
            detected = False
            first_name = _("Câmera não detectada")
            
            try:
                # Use a temporary file-based lock to avoid concurrent gphoto2 calls from multiple windows
                import fcntl
                lock_file = open('/tmp/gphoto2_detect.lock', 'w')
                try:
                    fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
                except BlockingIOError:
                    # Another instance is already detecting, just reset and return
                    def reset_detecting():
                        self._detecting = False
                        return False
                    GLib.idle_add(reset_detecting)
                    return False

                # Kill gvfs interference more effectively
                # Only do the heavy service stop if we are struggling or it's manual
                if getattr(self, '_manual_refresh', False) or getattr(self, '_missed_detections', 0) > 0 or not self.camera_detected:
                    subprocess.run(["systemctl", "--user", "stop", "gvfs-gphoto2-volume-monitor.service"], check=False, capture_output=True)
                
                subprocess.run(["gio", "mount", "-u", "gphoto2://*"], capture_output=True, check=False)
                
                # Small hardware settle time
                time.sleep(0.5)

                result = subprocess.run(
                    ["gphoto2", "--auto-detect"],
                    capture_output=True, text=True, timeout=12
                )
                output = result.stdout
                lines = output.strip().split('\n')
                for line in lines[2:]:
                    line = line.strip()
                    if line and 'usb:' in line:
                        parts = line.split('usb:')
                        if len(parts) >= 2:
                            name = parts[0].strip() or _("Câmera Genérica")
                            port = "usb:" + parts[1].strip()
                            local_list.append({"name": name, "port": port})
                
                if local_list:
                    detected = True
                    first_name = local_list[0]['name']

            except Exception as e:
                pass
            finally:
                def finalize_all():
                    nonlocal detected, local_list
                    # Check if our active camera is missing from the new list (it might be 'busy')
                    # If we are currently capturing, we MUST keep that port in the list.
                    active_port = self.get_selected_camera_port()
                    if active_port and self.is_capturing:
                        found_active = any(c['port'] == active_port for c in local_list)
                        if not found_active:
                            # Preserve it
                            local_list.insert(0, {"name": self.camera_name, "port": active_port})
                            detected = True

                    # ENHANCED PERSISTENCE:
                    # If detection returned fewer cameras than we had, some might just be busy.
                    # We merge the lists: current_detected + (previous_list if they were not in current)
                    if not detected and self.camera_list and not getattr(self, '_manual_refresh', False):
                        # FAILED PROBE: Keep everything for 3 cycles
                        if not hasattr(self, '_missed_detections'): self._missed_detections = 0
                        self._missed_detections += 1
                        if self._missed_detections <= 3: # 15 seconds
                            self._detecting = False
                            self._manual_refresh = False
                            # Still update UI in case switching modes or something happened
                            self.update_mode_ui()
                            if callback: callback()
                            return False
                    elif detected:
                        # SUCCESSFUL PROBE: Merge with previous to avoid flickering
                        # If a camera was in self.camera_list but not in local_list, 
                        # give it 2 grace cycles before removing.
                        merged_list = list(local_list)
                        new_ports = set(c['port'] for c in local_list)
                        
                        if not hasattr(self, '_grace_cameras'): self._grace_cameras = {}
                        
                        # Check previous cameras
                        for old_cam in self.camera_list:
                            if old_cam['port'] not in new_ports:
                                # Camera is missing now. Should we keep it?
                                count = self._grace_cameras.get(old_cam['port'], 0)
                                if count < 2: # Keep for 2 cycles
                                    self._grace_cameras[old_cam['port']] = count + 1
                                    merged_list.append(old_cam)
                                else:
                                    # Finally gone
                                    if old_cam['port'] in self._grace_cameras:
                                        del self._grace_cameras[old_cam['port']]
                            else:
                                # Still there, reset grace
                                if old_cam['port'] in self._grace_cameras:
                                    del self._grace_cameras[old_cam['port']]
                        
                        local_list = merged_list
                        self._missed_detections = 0
                    else:
                        self._missed_detections = 0
                        self._grace_cameras = {}

                    self.camera_list = local_list
                    self.camera_detected = (len(self.camera_list) > 0)
                    if self.camera_detected:
                        if not self.camera_name or self.camera_name == _("Câmera não detectada"):
                             self.camera_name = self.camera_list[0]['name']
                    else:
                        self.camera_name = _("Câmera não detectada")
                        
                    self._detecting = False
                    self._manual_refresh = False
                    
                    # Update UI directly here (consolidated)
                    self._update_camera_dropdown_logic()
                    self.update_mode_ui()
                    
                    if callback:
                        callback()
                    return False

                GLib.idle_add(finalize_all)

        import threading
        threading.Thread(target=run_detection, daemon=True).start()

    def _on_hotplug_event(self):
        """Called when Gio detects a hardware change."""
        self._manual_refresh = True
        self._missed_detections = 0
        # Short cooldown to let the OS settle the new device
        GLib.timeout_add(1000, lambda: self.detect_camera(callback=self._update_camera_dropdown) or False)
        return False

    def _poll_cameras(self):
        """Periodically poll for USB camera changes."""
        # CRITICAL: Do NOT poll if we are capturing or detecting.
        # This prevents 'PTP I/O Error' on Rebel T3 where multiple gphoto calls conflict.
        if self.is_capturing or self._detecting:
            # Reschedule for later
            if self._hotplug_timer:
                GLib.source_remove(self._hotplug_timer)
            self._hotplug_timer = GLib.timeout_add(10000, self._poll_cameras)
            return False

        # Extra safety: Check if ANY gphoto2 is still running in background
        try:
            res = subprocess.run(["pgrep", "-f", "gphoto2"], capture_output=True)
            if res.returncode == 0:
                if self._hotplug_timer:
                    GLib.source_remove(self._hotplug_timer)
                self._hotplug_timer = GLib.timeout_add(5000, self._poll_cameras)
                return False
        except: pass

        def on_done():
            # dropdown update already happened inside detect_camera -> finalize_all
            pass
        
        self.detect_camera(callback=on_done)
        # Dynamic polling: 5s if no cameras, 10s if we already have them
        interval = 5000 if not self.camera_detected else 10000
        if self._hotplug_timer:
            GLib.source_remove(self._hotplug_timer)
        self._hotplug_timer = GLib.timeout_add(interval, self._poll_cameras)
            
        return False # Stop current timer, we just scheduled a new one

    def _update_camera_dropdown_logic(self):
        """Internal logic to rebuild the dropdown model. Must be called from main thread."""
        if not hasattr(self, 'camera_dropdown') or self.camera_dropdown is None:
            return

        # Remember old selection
        old_selected = self.camera_dropdown.get_selected()
        old_port = None
        if hasattr(self, '_last_camera_list') and \
           old_selected != Gtk.INVALID_LIST_POSITION and \
           old_selected < len(self._last_camera_list):
            old_port = self._last_camera_list[old_selected]['port']
        
        new_items = []
        if self.camera_detected and self.camera_list:
            new_items = [cam['name'] for cam in self.camera_list]
        else:
            new_items = [_("Nenhuma câmera detectada")]

        # Create a FRESH model every time to prevent Segfault 139 (memory safety)
        new_model = Gtk.StringList.new(new_items)
        self.camera_dropdown.set_model(new_model)
        self.camera_model = new_model
        
        # Restore selection index by port
        new_idx = 0
        if old_port and self.camera_list:
            for i, c in enumerate(self.camera_list):
                if c['port'] == old_port:
                    new_idx = i
                    break
        
        self.camera_dropdown.set_selected(new_idx)
        self._last_camera_list = list(self.camera_list)

        # Update visuals
        is_error = not self.camera_detected
        icon_name = "dialog-error-symbolic" if is_error else "emblem-ok-symbolic"
        style_class = "error" if is_error else "success"
        
        self.status_icon.set_from_icon_name(icon_name)
        for cls in ["error", "success"]:
            self.status_icon.remove_css_class(cls)
            self.camera_dropdown.remove_css_class(cls)
        self.status_icon.add_css_class(style_class)
        self.camera_dropdown.add_css_class(style_class)
        
        if self.camera_detected and not is_error and not hasattr(self, '_first_detect_done'):
            self._first_detect_done = True
            self.show_toast(_("Câmera detectada!"), "success")

    def _update_camera_dropdown(self):
        """Deprecated: use direct call or GLib.idle_add(_update_camera_dropdown_logic)."""
        GLib.idle_add(self._update_camera_dropdown_logic)

    def check_existing_session(self):
        try:
            port = self.get_selected_camera_port()
            if not port:
                return
            
            # Check for a gphoto2 process specifically for THIS camera's port
            res = subprocess.run(["pgrep", "-af", f"gphoto2.*{port}"], capture_output=True, text=True)
            
            if res.returncode == 0 and res.stdout.strip():
                self.current_mode = "video"
                self.update_mode_ui()
                
                # Update state
                self.btn_action.set_visible(False)
                self.btn_stop.set_visible(True)
                
                self.show_toast(_("Sessão restaurada"), "accent")
                
                # Show status without trying preview (keeps v4l2loopback free for OBS)
                GLib.idle_add(self.show_webcam_active_status)
        except Exception as e:
            print(f"Erro ao verificar sessão: {e}")

    def take_photo(self):
        self.is_capturing = True
        self.btn_action.set_sensitive(False)
        self.set_loading(True)
        was_webcam_running = getattr(self, 'process', None) is not None
        if was_webcam_running:
            self.show_toast(_("Parando webcam..."), "warning")
            self.stop_video_preview()
            
            # Kill webcam processes
            self._kill_my_processes()
            self.process = None
            time.sleep(4) # More time for model 1100D/Rebel T3 mirror mechanics
        
        # Switch to photo view
        self.current_mode = "photo"
        self.update_mode_ui()
        self.btn_action.set_visible(True)
        self.btn_stop.set_visible(False)
        
        def do_capture():
            try:
                # Kill interfering processes more aggressively
                subprocess.run(["systemctl", "--user", "stop", "gvfs-gphoto2-volume-monitor.service"], check=False)
                subprocess.run(["pkill", "-9", "-f", "gvfs-gphoto2-volume-monitor"], check=False)
                subprocess.run(["gio", "mount", "-u", "gphoto2://*"], capture_output=True, check=False)
                
                # Reset the camera USB state
                port = self.get_selected_camera_port()
                port_arg = ["--port", port] if port else []
                subprocess.run(["gphoto2", "--reset"] + port_arg, capture_output=True, check=False)
                
                time.sleep(4) # Settle down time after reset
                
                target_filename = self.get_next_filename()
                GLib.idle_add(lambda: self.show_toast(f"{_('Capturando')} {target_filename}...", "accent"))
                
                port = self.get_selected_camera_port()
                port_arg = ["--port", port] if port else []
                
                result = subprocess.run(
                    ["gphoto2", "--capture-image-and-download", "--filename", target_filename, "--force-overwrite", "--keep"] + port_arg,
                    check=True, capture_output=True, text=True, timeout=60
                )
                
                GLib.idle_add(self.on_photo_captured, target_filename)
                
            except subprocess.TimeoutExpired:
                GLib.idle_add(self.on_photo_error, _("Timeout - câmera demorou muito"))
            except subprocess.CalledProcessError as e:
                error_msg = e.stderr if e.stderr else str(e)
                GLib.idle_add(self.on_photo_error, error_msg)
            except Exception as e:
                GLib.idle_add(self.on_photo_error, str(e))
        
        import threading
        threading.Thread(target=do_capture, daemon=True).start()

    def on_photo_captured(self, filename):
        self.last_photo = filename
        self.load_last_photo()
        self.set_loading(False)
        self.show_toast(f"{_('Foto salva:')} {filename}", "success")
        
        # Give camera 2 seconds to settle before allowing next action
        def unlock():
            self.is_capturing = False
            self.update_mode_ui() # This handles both btn and dropdown
            self.ask_open_photo(filename)
            return False
            
        GLib.timeout_add(2000, unlock)
        return False

    def on_photo_error(self, error):
        self.set_loading(False)
        self.show_toast(_("Erro na câmera, limpando estado..."), "error")
        print(f"[Photo Error] {error}")
        
        # Reset camera in background
        def do_reset():
            port = self.get_selected_camera_port()
            port_arg = ["--port", port] if port else []
            subprocess.run(["gphoto2", "--reset"] + port_arg, capture_output=True)
            return False
            
        threading.Thread(target=do_reset, daemon=True).start()
        
        # Still do a cooldown before unlocking
        def unlock_err():
            self.is_capturing = False
            self.update_mode_ui()
            return False
            
        GLib.timeout_add(3000, unlock_err)
        return False

    def get_next_filename(self):
        files = glob.glob("capt*.jpg")
        max_idx = 0
        for f in files:
            try:
                num_part = f[4:-4]
                idx = int(num_part)
                if idx > max_idx:
                    max_idx = idx
            except:
                pass
        return f"capt{max_idx+1:04d}.jpg"

    def start_webcam(self, is_retry=False):
        """Starts the webcam script in a separate thread.
           is_retry: if True, doesn't reset the retry counter.
        """
        self.is_capturing = True
        if not is_retry:
            self._webcam_retry_count = 0
            
        self.btn_action.set_sensitive(False)
        self.set_loading(True)
        
        # Kill everything before starting to ensure a clean slate
        if is_retry:
            self.show_toast(f"{_('Reiniciando Webcam')} ({self._webcam_retry_count}/4)...", "warning")
        else:
            self.show_toast(_("Iniciando Webcam..."), "accent")
            
        # Ensure preview is stopped before starting new stream
        self.stop_video_preview()
        self._kill_my_processes()
        
        # No blocking sleep in UI thread
        self.btn_action.set_visible(False)
        self.btn_stop.set_visible(True)
        
        # Determine correct path relative to this script
        base_dir = os.path.dirname(os.path.realpath(__file__))
        script_path = os.path.join(base_dir, "script", "run_webcam.sh")
        
        # Ensure it is executable
        if not os.access(script_path, os.X_OK):
            try:
                os.chmod(script_path, 0o755)
            except:
                pass
                
        def run_script_thread():
            try:
                # Give extra time in background thread for camera to settle
                # Canon T3 needs even more time (4s) to release the bus completely
                time.sleep(5.0)
                port = self.get_selected_camera_port()
                port_arg = port if port else ""
                
                # Run the script and wait for it to finish (it waits for device ready)
                # We use bytes capture to avoid UTF-8 decoding errors if camera returns weird data
                res = subprocess.run(
                    [script_path, port_arg, str(self.udp_port)],
                    capture_output=True,
                    timeout=120 # 2 minutes timeout for the whole setup
                )
                
                # Decode with 'replace' to avoid crashes
                stdout = res.stdout.decode('utf-8', errors='replace') if res.stdout else ""
                stderr = res.stderr.decode('utf-8', errors='replace') if res.stderr else ""
                output = stdout + stderr
                
                # Check retuncode
                if res.returncode == 0:
                    # Success path - script outputs "SUCCESS: /dev/videoX"
                    dev = None
                    for line in output.split('\n'):
                        line = line.strip()
                        if line.startswith('SUCCESS:'):
                            dev = line.split('SUCCESS:')[1].strip()
                            break
                    GLib.idle_add(self.on_webcam_started_success, dev)
                else:
                    # Failure path
                    error_msg = output.strip()
                    if not error_msg:
                        error_msg = "Unknown Error (No Output)"
                        
                    print(f"Script failed (code {res.returncode}): {error_msg}")
                    GLib.idle_add(self.on_webcam_started_error, error_msg, res.returncode)
                    
            except subprocess.TimeoutExpired:
                GLib.idle_add(self.on_webcam_started_error, "Timeout (2 min) exceeded during setup", -1)
            except Exception as e:
                GLib.idle_add(self.on_webcam_started_error, str(e), -2)

        import threading
        threading.Thread(target=run_script_thread, daemon=True).start()

    def on_webcam_started_success(self, video_device=None):
        self.set_loading(False)
        if video_device:
            self.my_video_device = video_device
        self.show_webcam_active_status()

    def show_webcam_active_status(self):
        # Use the device assigned by run_webcam.sh to THIS instance
        if self.my_video_device and os.path.exists(self.my_video_device):
            self.preview_device = self.my_video_device
        else:
            # Fallback: find last device
            devices = sorted(glob.glob("/dev/video*"))
            if not devices:
                return
            self.preview_device = devices[-1]
        
        # Try to start preview (Wait 2s for ffmpeg to really settle the CAPS on the device)
        GLib.timeout_add(2000, self.start_video_preview)

    def on_webcam_started_error(self, error_msg, returncode=None):
        """Called when the webcam script fails or exits with error."""
        self.is_capturing = False
        self.set_loading(False)
        self.update_mode_ui()
        
        # If no output, try to provide a generic hint
        if not error_msg.strip():
            error_msg = f"Unknown Error (Exit Code: {returncode})" if returncode else "Unknown Error (Process crashed)"
        
        # Retry logic: Try up to 4 times before giving up
        if not error_msg.strip():
            error_msg = f"Unknown Error (Exit Code: {returncode})" if returncode else "Unknown Error (Process crashed)"
        
        # Retry logic: Try up to 4 times before giving up
        if self._webcam_retry_count < 3:
            self._webcam_retry_count += 1
            delay_sec = 2 + (self._webcam_retry_count * 2) 
            retry_msg = f"{_('Câmera ocupada, tentando novamente')} ({self._webcam_retry_count}/4)..."
            self.show_toast(retry_msg, "warning")
            print(f"Webcam Error: {error_msg}. Retrying {self._webcam_retry_count} with {delay_sec}s delay...")
            
            def do_retry():
                self._kill_my_processes()
                # Extra forced reset outside the script for good measure
                port = self.get_selected_camera_port()
                if port:
                    subprocess.run(["gphoto2", "--port", port, "--reset"], capture_output=True)
                
                # Instead of sleep, schedule the final start
                GLib.timeout_add(delay_sec * 1000, lambda: self.start_webcam(is_retry=True) or False)
                return False
            
            GLib.timeout_add(1000, do_retry)
        else:
            self.show_toast(_("Erro ao iniciar webcam após várias tentativas"), "error")
            dialog = Adw.AlertDialog(
                heading=_("Erro na Webcam"),
                body=f"{_('Não foi possível iniciar a webcam.')}\n\n{_('Dica: Verifique se a câmera está no modo Manual (M) e se o foco está em MF.')}\n\nErro: {error_msg}"
            )
            dialog.add_response("ok", _("OK"))
            dialog.choose(self.win, None, None)
            self._webcam_retry_count = 0

    def start_video_preview(self):
        self.set_loading(True)
        # self.show_toast("Aguardando stream...", "warning")
        
        # Determine device
        devices = sorted(glob.glob("/dev/video*"))
        if not devices:
            self.show_toast(_("Nenhum dispositivo"), "warning")
            self.set_loading(False)
            return
        self.preview_device = devices[-1]
        
        # Wait for device to be ready (ffmpeg needs time to start streaming)
        self._preview_retry_count = 0
        self._preview_max_retries = 30  # 30 * 500ms = 15 seconds max wait
        GLib.timeout_add(500, self._try_start_gst_preview)

    def _try_start_gst_preview(self):
        self._preview_retry_count += 1
        
        try:
            # Skip v4l2-ctl check which might fail if device is busy
            # Just verify if we have retried enough times to allow ffmpeg to start
            if self._preview_retry_count < 3: # Wait at least 1.5s
                # self.show_toast(f"Iniciando stream... ({self._preview_retry_count})", "warning")
                return True

            # Device ready or max retries reached, try to start
            self.use_opencv = False
            self.preview_active = True
            self.fps_counter = 0
            self.last_fps_time = time.time()
            
            # Try UDP stream (Guaranteed no conflict)
            # Using packetsize=1316 to match ffmpeg output
            pipeline_attempts = [
                # Try 1: Explicit MPEG-TS caps with localhost bind
                (
                    f"udpsrc port={self.udp_port} address=127.0.0.1 caps=\"video/mpegts,packetsize=(int)1316\" ! "
                    "queue max-size-bytes=65536 ! "
                    "tsdemux ! "
                    "decodebin ! "
                    "videoconvert ! "
                    "video/x-raw,format=RGB ! "
                    "appsink name=sink emit-signals=True drop=True max-buffers=2 sync=False"
                ),
                # Try 2: Bind to ALL interfaces (0.0.0.0) just in case
                (
                    f"udpsrc port={self.udp_port} caps=\"video/mpegts,packetsize=(int)1316\" ! "
                    "queue ! "
                    "decodebin ! "
                    "videoconvert ! "
                    "video/x-raw,format=RGB ! "
                    "appsink name=sink emit-signals=True drop=True max-buffers=2 sync=False"
                ),
            ]
            
            for i, pipeline_str in enumerate(pipeline_attempts):
                try:
                    # print(f"[Preview] Tentando pipeline {i+1}...")
                    self.gst_pipeline = Gst.parse_launch(pipeline_str)
                    appsink = self.gst_pipeline.get_by_name("sink")
                    appsink.connect("new-sample", self.on_gst_sample_with_fps)
                    
                    bus = self.gst_pipeline.get_bus()
                    bus.add_signal_watch()
                    bus.connect("message::error", self.on_gst_error)
                    
                    # Try to start
                    ret = self.gst_pipeline.set_state(Gst.State.PLAYING)
                    if ret == Gst.StateChangeReturn.FAILURE:
                        print(f"[Preview] Pipeline {i+1} falhou ao iniciar")
                        self.gst_pipeline.set_state(Gst.State.NULL)
                        self.gst_pipeline = None
                        continue
                    
                    # Wait a bit to see if it errors immediately (MAX 2 seconds)
                    # Don't use CLOCK_TIME_NONE as it freezes the UI waiting for stream
                    ret, state, pending = self.gst_pipeline.get_state(2 * Gst.SECOND)
                    
                    if ret == Gst.StateChangeReturn.FAILURE:
                         print(f"[Preview] Pipeline {i+1} falhou state change")
                         self.gst_pipeline.set_state(Gst.State.NULL)
                         self.gst_pipeline = None
                         continue
                         
                    if state == Gst.State.PLAYING or ret == Gst.StateChangeReturn.SUCCESS or ret == Gst.StateChangeReturn.ASYNC:
                        # print(f"[Preview] Pipeline {i+1} iniciado (State: {state}, Ret: {ret})")
                        # self.show_toast(f"Preview ativo", "accent")
                        GLib.timeout_add(500, lambda: self.show_toast(_("Webcam disponível!"), "success") or False)
                        self.set_loading(False)
                        return False
                        
                except Exception as e:
                    print(f"[Preview] Pipeline {i+1} erro: {e}")
                    if self.gst_pipeline:
                        self.gst_pipeline.set_state(Gst.State.NULL)
                        self.gst_pipeline = None
                    continue
            
            # All pipelines failed - show message but don't block OBS
            print("[Preview] Todos pipelines falharam")
            # self.show_toast("Preview indisponível (OBS/Meet funcionam)", "warning")
            self.preview_active = False
            self.set_loading(False)
            # Alternative: Try OpenCV Fallback?
            # self.try_opencv_fallback()
            return False
            
        except Exception as e:
            if self._preview_retry_count < self._preview_max_retries:
                return True  # Retry
            self.show_toast("Preview indisponível", "warning")
            self.set_loading(False)
            return False

    def update_opencv_frame(self):
        if not self.preview_active or not hasattr(self, 'cap'):
            return False
            
        ret, frame = self.cap.read()
        if ret:
            # FPS Calc
            self.fps_counter += 1
            t = time.time()
            if t - self.last_fps_time >= 1.0:
                fps = self.fps_counter
                self.fps_counter = 0
                self.last_fps_time = t
                self.fps_label.set_label(f"FPS {fps}")
                # Only show FPS in video mode
                if self.current_mode == "video":
                    self.fps_label.set_visible(True)

            # Convert BGR to RGB
            # Frame is numpy array
            import cv2
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            h, w, ch = rgb_frame.shape
            data = rgb_frame.tobytes()
            glib_bytes = GLib.Bytes.new(data)
            
            self.update_texture(w, h, glib_bytes)
            
        return True # Keep calling

    def on_gst_sample_with_fps(self, sink):
        if not self.preview_active:
            return Gst.FlowReturn.ERROR
        sample = sink.emit("pull-sample")
        if not sample:
            return Gst.FlowReturn.ERROR
        
        # FPS Calculation
        self.fps_counter += 1
        t = time.time()
        if t - self.last_fps_time >= 1.0:
            fps = self.fps_counter
            self.fps_counter = 0
            self.last_fps_time = t
            GLib.idle_add(lambda: self.fps_label.set_label(f"FPS {fps}") or self.fps_label.set_visible(self.current_mode == "video"))
        
        buf = sample.get_buffer()
        caps = sample.get_caps()
        s = caps.get_structure(0)
        w = s.get_value("width")
        h = s.get_value("height")
        result, map_info = buf.map(Gst.MapFlags.READ)
        if result:
            glib_bytes = GLib.Bytes.new(map_info.data)
            buf.unmap(map_info)
            GLib.idle_add(self.update_texture, w, h, glib_bytes)
        return Gst.FlowReturn.OK

    def on_gst_error(self, bus, msg):
        err, debug = msg.parse_error()
        print(f"[GStreamer Error] {err}: {debug}")
        self.show_toast("Erro no preview, tentando alternativa...", "warning")
        GLib.idle_add(self.try_opencv_fallback)

    def try_opencv_fallback(self):
        try:
            import cv2
            dev_idx = int(re.search(r'\d+$', self.preview_device).group())
            self.cap = cv2.VideoCapture(dev_idx, cv2.CAP_V4L2)
            if self.cap.isOpened():
                self.use_opencv = True
                self.preview_active = True
                self.fps_counter = 0
                self.last_fps_time = time.time()
                GLib.timeout_add(33, self.update_opencv_frame)
                self.show_toast("Preview via OpenCV (acesso exclusivo)", "warning")
            else:
                self.show_toast("Falha no fallback OpenCV", "error")
        except Exception as e:
            self.show_toast(f"Fallback falhou: {e}", "error")


    def update_texture(self, w, h, glib_bytes):
        if not self.preview_active:
            return
            
        try:
            texture = Gdk.MemoryTexture.new(
                w, h, 
                Gdk.MemoryFormat.R8G8B8, 
                glib_bytes, 
                w * 3
            )
            self.video_picture.set_paintable(texture)
        except:
            pass

    def stop_video_preview(self):
        """Stop preview (OpenCV or GStreamer)."""
        self.preview_active = False
        self.fps_label.set_visible(False)
        
        # Stop OpenCV
        if hasattr(self, 'cap') and self.cap:
            self.cap.release()
            self.cap = None
        
        # Stop GStreamer
        if self.gst_pipeline:
            # First, stop message handling to avoid race conditions
            bus = self.gst_pipeline.get_bus()
            bus.remove_signal_watch()
            
            # Disconnect new-sample to avoid more texture updates
            appsink = self.gst_pipeline.get_by_name("sink")
            if appsink:
                try:
                    appsink.disconnect_by_func(self.on_gst_sample_with_fps)
                except: pass
            
            # Change state and WAIT for it to complete
            self.gst_pipeline.set_state(Gst.State.NULL)
            self.gst_pipeline.get_state(Gst.SECOND) # Wait up to 1s
            
            self.gst_pipeline = None
            
        self.video_picture.set_paintable(None)
    def on_stop_clicked(self, btn):
        self.is_capturing = False
        self.btn_action.set_sensitive(True)
        self.stop_video_preview()
        
        if self.process:
            try:
                os.killpg(os.getpgid(self.process.pid), signal.SIGTERM)
                self.process = None
            except:
                pass

        # Only kill THIS instance's processes (not other cameras)
        self._kill_my_processes()
        self.my_video_device = None
        
        self.btn_action.set_visible(True)
        self.btn_stop.set_visible(False)
        self.fps_label.set_visible(False)
        self.show_toast("Webcam parada", "warning")
        self.update_mode_ui()

    def ask_open_photo(self, filename):
        def on_response(dialog, result):
            try:
                response = dialog.choose_finish(result)
                if response == "open":
                    subprocess.run(["xdg-open", filename])
            except:
                pass

        dialog = Adw.AlertDialog(
            heading="Foto Capturada",
            body=f"'{filename}' foi salva.\nDeseja abrir?"
        )
        dialog.add_response("cancel", "Não")
        dialog.add_response("open", "Sim")
        dialog.set_default_response("open")
        dialog.set_close_response("cancel")
        dialog.choose(self.win, None, on_response)

    def set_loading(self, loading=True):
        if hasattr(self, 'loading_bar'):
             self.loading_bar.set_visible(loading)
             
        if loading:
            if not hasattr(self, '_pulse_timer') or self._pulse_timer is None:
                self._pulse_timer = GLib.timeout_add(100, self._pulse_progress)
        else:
            if hasattr(self, '_pulse_timer') and self._pulse_timer:
                try:
                    GLib.source_remove(self._pulse_timer)
                except:
                    pass
                self._pulse_timer = None

    def _pulse_progress(self):
        if hasattr(self, 'loading_bar') and self.loading_bar.get_visible():
            self.loading_bar.pulse()
            return True
        return False

    def show_toast(self, message, style=None):
        self.top_toast_label.set_label(message)
        
        # Reset classes
        self.top_toast_label.set_css_classes(["top-toast"])
        if style:
            self.top_toast_label.add_css_class(style)
            
        self.top_toast_revealer.set_reveal_child(True)
        if hasattr(self, '_toast_timer') and self._toast_timer is not None:
            try:
                GLib.source_remove(self._toast_timer)
            except:
                pass
            self._toast_timer = None
            
        self._toast_timer = GLib.timeout_add(3000, self.hide_top_toast)

    def hide_top_toast(self):
        self.top_toast_revealer.set_reveal_child(False)
        self._toast_timer = None
        return False



if __name__ == '__main__':
    app = WebcamApp()
    app.run(sys.argv)
