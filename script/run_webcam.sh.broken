#!/bin/bash
exec 2>&1

USB_PORT="$1"
UDP_PORT="${2:-5000}"

echo "[Script] Iniciando setup da webcam..."

if [ -n "$USB_PORT" ]; then
  echo "[Script] Usando porta USB: $USB_PORT"
  PORT_STR="--port $USB_PORT"
  # Kill only THIS camera's previous instances
  pkill -f "gphoto2.*--port $USB_PORT" 2>/dev/null
  pkill -f "ffmpeg.*udp://127.0.0.1:$UDP_PORT" 2>/dev/null
  sleep 1
else
  echo "[Script] Nenhuma porta USB especificada, usando auto-detecção."
  PORT_STR=""
fi

# Kill everything that could be using the camera or video devices
echo "[Script] Limpando processos gvfs e gphoto2..."
systemctl --user stop gvfs-gphoto2-volume-monitor.service 2>/dev/null
pkill -9 -f "gvfs-gphoto2-volume-monitor" 2>/dev/null
# Broad but targeted kills to clear the bus
pkill -9 -f "gphoto2" 2>/dev/null
pkill -9 -f "ffmpeg.*v4l2.*Canon DSLR" 2>/dev/null
pkill -9 -f "ffmpeg.*udp://127.0.0.1:$UDP_PORT" 2>/dev/null
sleep 1
gio mount -u gphoto2://* 2>/dev/null
sleep 2

# Reset the USB interface of the camera before starting
echo "[Script] Resetando interface USB da câmera..."
if [ -n "$USB_PORT" ]; then
    # Try to explicitly close any pending liveview - SILENTLY
    timeout 4 gphoto2 --port "$USB_PORT" --set-config liveview=0 >/dev/null 2>&1
    sleep 1
    timeout 10 gphoto2 --port "$USB_PORT" --reset >/dev/null 2>&1
else
    timeout 4 gphoto2 --set-config liveview=0 >/dev/null 2>&1
    sleep 1
    timeout 10 gphoto2 --reset >/dev/null 2>&1
fi
sleep 5

echo "[Script] Configurando v4l2loopback..."
# Load v4l2loopback with 4 virtual devices if not loaded
if ! lsmod | grep -q v4l2loopback; then
  echo "[Script] Carregando módulo v4l2loopback..."
  bigsudo modprobe v4l2loopback devices=4 exclusive_caps=0 max_buffers=4 card_label="Canon DSLR Webcam,Canon DSLR Webcam 2,Canon DSLR Webcam 3,Canon DSLR Webcam 4"
  sleep 1
else
  # If loaded with exclusive_caps=1, reload only if no device is in use
  if [ "$(cat /sys/module/v4l2loopback/parameters/exclusive_caps 2>/dev/null)" = "1" ]; then
    echo "[Script] Recarregando v4l2loopback para modo compartilhado..."
    if ! fuser /dev/video* >/dev/null 2>&1; then
      bigsudo modprobe -r v4l2loopback 2>/dev/null
      sleep 2
      bigsudo modprobe v4l2loopback devices=4 exclusive_caps=0 max_buffers=4 card_label="Canon DSLR Webcam,Canon DSLR Webcam 2,Canon DSLR Webcam 3,Canon DSLR Webcam 4"
      sleep 2
    else
      echo "[Script] Aviso: Dispositivo em uso, mantendo configuração atual do v4l2loopback."
    fi
  fi
fi

echo "[Script] Buscando dispositivo de vídeo disponível..."

# Find a free v4l2loopback virtual device
DEVICE_VIDEO=""
for dev in $(ls -v /dev/video* 2>/dev/null); do
  # Check driver and card info
  V4L_INFO=$(v4l2-ctl -d "$dev" --info 2>/dev/null)
  DRIVER=$(echo "$V4L_INFO" | grep "Driver name" | awk '{print $NF}')
  CARD=$(echo "$V4L_INFO" | grep "Card type" | sed 's/.*: //')
  
  # Check if it looks like a loopback device
  if echo "$DRIVER" | grep -qi "v4l2loopback\|loopback" || echo "$CARD" | grep -qi "v4l2loopback\|Canon DSLR\|Dummy\|Virtual"; then
    # Give it a tiny bit of time to be released if just closed
    for wait_fuser in {1..5}; do
      if ! fuser "$dev" >/dev/null 2>&1; then
        DEVICE_VIDEO="$dev"
        break 2
      fi
      sleep 0.2
    done
  fi
done

[ -z "$DEVICE_VIDEO" ] && echo "ERROR: No free virtual video device found." && exit 1

# Verify camera is connected with a timeout to prevent hang
# Retry up to 3 times because GVFS might grab it immediately after reset
FOUND=0
for i in {1..3}; do
  if [ -n "$USB_PORT" ]; then
    if timeout 10 gphoto2 --auto-detect 2>&1 | grep -q "$USB_PORT"; then
      FOUND=1
      break
    fi
  else
    if timeout 10 gphoto2 --auto-detect 2>&1 | grep -q "usb:"; then
      FOUND=1
      break
    fi
  fi
  echo "Camera busy or not found, retrying in 2s... ($i/3)"
  sleep 2
done

if [ "$FOUND" != "1" ]; then
  echo "ERROR: Camera not found or device busy after retries."
  exit 1
fi

LOG="/tmp/canon_webcam_stream_${UDP_PORT}.log"
ERR_LOG="/tmp/gphoto_err_${UDP_PORT}.log"
> "$LOG"
> "$ERR_LOG"

# Launch gphoto2 + ffmpeg pipeline in background
nohup bash -c "gphoto2 --stdout --capture-movie $PORT_STR 2>\"$ERR_LOG\" | ffmpeg -y -hide_banner -loglevel error -stats -i - -filter_complex \"[0:v]format=yuv420p,split=2[v1][v2_pre];[v2_pre]scale=700:480,format=yuv420p[v2]\" -map \"[v1]\" -r 60 -f v4l2 \"$DEVICE_VIDEO\" -map \"[v2]\" -f mpegts -r 60 -codec:v mpeg1video -b:v 800k -bf 0 \"udp://127.0.0.1:${UDP_PORT}?pkt_size=1316\" >\"$LOG\" 2>&1" &
PID=$!
disown

# Wait for it to stabilize
# Rebel T3 takes a while to start movie capture after a photo
echo "Waiting for stream to stabilize..."
for j in {1..10}; do
  if kill -0 $PID 2>/dev/null; then
    # Process is alive, check if log has any output (optional)
    sleep 1
  else
    echo "ERROR: Pipeline died prematurely at second $j."
    break
  fi
  
  if [ $j -eq 5 ] && kill -0 $PID 2>/dev/null; then
     echo "Stream looks promising..."
  fi
done

if kill -0 $PID 2>/dev/null; then
  echo "SUCCESS: $DEVICE_VIDEO"
  exit 0
else
  echo "ERROR: Pipeline failed to start."
  cat "$LOG"
  cat "$ERR_LOG"
  exit 1
fi
